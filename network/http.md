# HTTP

# 연관
  - HTTP 7230~7235 확인 할 것


# 계층구조
<img src="https://media.vlpt.us/images/2jaeyeol/post/c3450941-be18-4819-be2c-436d24f970d5/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%20%E1%84%80%E1%85%A8%E1%84%8E%E1%85%B3%E1%86%BC.png"  width="700" height="370">

# IP(인터넷 프로토콜)
- 지정한 IP주소에 데이터 전달
- 패킷이라는 통신단위로 데이터 전달
- 한계
  - 비연결성 : 패킷을 받을 대상이 없거나 서비스 불능이어도 패킷 전달
  - 비신뢰성 : 패킷이 사라지거나 중간에 없어지는 경우(보통 패킷을 크기만큼 끊어서 전달함)
  - 구분 : 같은 IP를 사용하는 애플리케이션 둘 이상인 경우
<br/><br/>
# TCP UDP( IP문제의 해결 )
- IP패킷 안에 TCP정보가 들어감( ex : 전송제어 , 순서 , 검증정보 등.. )
- TCP(전송제어 프로토콜)
  - 연결지향 TCP 3 way handshake(연결을 하고 메세지를 보냄)
  - 데이터 전달 보증(누락)
  - 순서 보장
- UDP(사용자 데이터그램 프로토콜)
  - 기능이 거의 없음
  - IP와 거의 같음(+PORT, +checksum 정도 추가)
    - PORT : 같은 IP내에서 프로세스를 구분
  - 애플리케이션에서 추가작업이 필요함
  - 속도가 빠르다
<br/><br/>
# DNS
- IP는 변경될 수 있다.
- 도메인명을 IP주소로 변환
<br/><br/>
# URI? URL? URN?
<img src="https://media.vlpt.us/images/2jaeyeol/post/0f9757ed-6f1f-40d9-88e2-444ece859571/URI.png"  width="700" height="370">
  ## URI
    - Locator , name 또는 둘다 추가 분류 가능
  ## URL
    - Locator
  ## URN
    - name
<br/><br/>
# HTTP
  - 특징
    - 클라이언트 서버 구조
      - Request , Response 구조
      - 클라이언트와 서버를 분리 하는것이 중요
    - 무상태 프로토콜 , 비연결성
      - 서버가 클라이언트의 상태를 보존x
      - 응답 서버를 쉽게 바꿀수 있다 -> 무한한 서버 증설 가능
      - 여러개의 클라이언트가 한 서버에 접속할때 클라이언트 간의 연결을 끊음(자원을 최소화) 
    - HTTP 메세지
      - 요청 메시지와 응답 메시지의 구조가 다름 
    - 단순함 , 확장가능
  - 1.1 버전을 가장 많이 사용(대부분의 스펙이 다 들어있음)
  - HTTP(1.1 , 2) : TCP
  - HTTP(3) : UDP
<br/><br/>
# HTTP 메서드
  - ## API
    - ex) 회원 조회, 등록 등등.. 에서 '회원조회' 가 리소스가 아니라 '회원' 자체가 리소스 이다.
  - ## 메서드
    - GET : 리소스 조회
    - POST : 요청 데이터 처리 , 주로 등록에 사용
      - 무조건 등록만이 아닌 URI에 POST요청이 오면 리소스마다 데이터를 어떻게 처리할지 정해야 함
      - 서버에서 URI를 만들어줌(collection)
    - PUT : 리소스를 대체 , 해당 리소스가 없으면 생성
      - 완전대체
      - 클라이언트가 리소스의 위치를 알고 URI지정(POST와의 차이점)
    - PATCH : 리소스 부분 변경
    - DELETE : 리소스 삭제
<br/><br/>
# 상태코드
  - 1xx(Informational) : 요청이 처리중 
  - 2xx(Successful) : 요청 정상 처리
    - 200 OK 
    - 201 Created 새로운 리소스 생성
    - 202 Accepted 요청이 접수되었으나 처리가 완료가 안됨(ex batch)
    - 204 No Contents 요청을 성공적으로 했지만 보낼 데이터가 없음
  - 3xx(Redirection) : 요청을 완료하려면 추가 행동 필요
    - Redirect : 3xx 결과에 Location 헤더가 있으면 그 Location으로 자동 이동(영구, 일시, 특수(결과대신 캐시이용)) <br/>
    ex) 만약 /new 라는 곳으로 보냈는데 /new1로 바뀌면 보내주는 것
    - 영구 Redirection
      - 301 Moved Permanently 리다이렉트시 요청 메서드가 GET으로 변하고 본문이 제거 될 수 있음
      - 308 Permanent Rediret 301과 기능은 같으나 본문이 유지

    - 일시 Redirection(URI를 바꾸면 안됨)
      - 302 Found 리다이렉트시 요청 메서드가 GET으로 변하고 본문이 제거 될 수 있음
      - 303 See Other 명확하게 GET으로 바뀜
      - 307 Temporary Redirection 302와 기능은 같으나 본문을 
      __무조건__ 유지해야함
      - 304 Not Modified 캐시를 목적으로 사용(응답에 바디를 포함하면 안된다)
      - 새로고침을 할때 발생할 수 있음(중복이 될 수 있음)
  - 4xx(Client Error) : 클라이언트 오류
    - 오류의 원인이 클라이언트에 있음
    - 5xx 와의 차이점은 4xx는 수정해서 보내야 하고 5xx 는 클라이언트가 나중에 똑같은 요청을 보내도 성공할 수 있다.
    - 401 Unauthorized 클라이언트가 해당 리소스에 대해 인증이 필요함 
    - 403 Forbidden 서버가 요청을 했지만 거절(접근권한)
    - 404 Not Found 요청 리소스가 서버에 없음
  - 5xx(Server Error) : 서버 오류
    - 500 Internal Server Error 서버 내부 문제로 오류 발생
    - 503 Service Unavailable 서비스 이용 불가
      - 서버를 잠시 이용 불가
      - Retry-After 헤더 필드로 언제 복구 되는지 알려줄 수 있음
<br/><br/>
# HTTP Header
  - HTTP 전송에 필요한 모든 부가정보
  - 표현
    - Content-Type : 데이터 형식(미디어타입,문자 인코딩)
    - Content-Encoding : 데이터 압축방식
    - Content-Language : 데이터 언어
    - Content-Length : 데이터 길이(전송 코딩을 사용하면 사용하면 안됨)
  
  - 협상(클라이언트가 선호하는 표현 요청) - 요청시만 사용
    - Accept : 선호 미디어타입
    - Accept-Charset : 선호 문자 인코딩
    - Accept-Encoding : 선호 압축 인코딩
    - Accept-Language : 선호 자연 언어
    - 우선순위 : 0~1 클수록 높은 우선순위 ex) ko;q=0.9
  
  - 전송 방식
    - 단순 전송 : Content-Length를 알고 있을때 그에 대한 전송을 줘라
    - 압축 전송 : Content-Encoding 사용
    - 분할 전송 : Content-Encoding = chunked 사용, Content-Length 사용x
    - 범위 전송 : Content-Range 사용 

  - 일반 정보
    - Form : 유저 에이전트의 이메일 정보 
    - Referer : 이전 웹페이지 주소(유입 경로 분석할때 사용)
    - User-agent : 유저 에이전트 애플리케이션 정보(특정 브라우저에 장애가 발생하는지 파악가능, 통계정보, 웹 브라우저 정보 등..)
    - Server : 요청을 처리하는 ORIGIN(진짜 서버 프록시나 캐시를 제외한) 서버의 소프트웨어 정보
    - Date : 메시지가 발생한 날짜와 시간
  
  - 특수 정보
    - Host(요청) : __필수값__ , 하나의 서버가 여러 도메인을 처리할때 
      - 가상 호스트를 통해 여러 도메인을 한번에 처리
      - Host가 없으면 IP로만 전달하기 때문에 aaa.com , bbb.com 어떤 곳으로 통신하는지 모른다.
    - Location
      - 201에서도 사용가능 
    - Allow : 허용 가능한 HTTP메서드
      - 405 에서 응답에 포함해야함 어떤 메서드를 지원하는지
    - Retry-After : 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
    
  - 인증(인증의 매커니즘에 따라 다름)
    - Authorization : 클라이언트 인증 정보를 서버에 전달
    - WWW-Authenticate : 리소스 접근시 필요한 인증방법 정의
      - 401 응답과 함께 사용
  
  - 쿠키
    - Set-Cookie : 서버에서 클라이언트로 쿠키 전달(응답)
    - Cookie : 클라이언트가 서버에서 받은 쿠키를 저장하고, Http 요청 시 서버로 전달
    - 쿠키 미사용 시
      - ex) 로그인 정보를 기억못함(HTTP는 기본적으로 Stateless 프로토콜이기 때문에)
    - 사용자 로그인, 광고 정보 트래킹 등에 사용
    - 쿠키정보는 항상 서버에 전송됨
      - 네트워크 트래픽 추가 유발
      - 최소한의 정보만 사용해야함(세션id, 인증 토큰 등.)
      - 서버에 전송하지 않고 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지(localStroage, sessionStorage)를 알아볼것
      - 보안에 민감한 데이터는 저장하면 안됨
    - 생명주기
      - Set-Cookie 에서 expires, max-age 등 이용 (세션쿠키, 영속 쿠키)
    - 도메인
      - 명시 : 명시한 문서 기준 도메인 + 서브 도메인 포함
      - 생략 : 현재 문서 기준 도메인만 적용
    - 경로
      - 도메인으로 필터하고 그다음 경로로 필터
      - 경로를 포함한 하위 경로 페이지만 쿠키접근
    - 보안
      - Secure : 쿠키는 http, https를 구분하지 않고 전송함 Secure를 적용하면 https의 경우에만 전송
      - HttpOnly : XSS 공격 방지(js에서 접근불가, http전송에만 사용)
      - SameSite : XSRF 공격방지 , 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키전송(브라우저에서 어느정도까지 지원하는지 확인필요)
<br/><br/>
# 캐시
  - 캐시가 없을때
    - 데이터가 변경되지 않아도 계속 네트워크를 통해 데이터를 받아와야함
  - 캐시 적용
    - 캐시 가능시간동안 네트워크를 이용하지 않아도됨
    - cache-control 로 유효시간 결정
    - 캐시 시간이 초과되면 다시 캐시에 저장해야한다.
  - 캐시 시간초과
    - 기존 데이터와 같을 경우 : 저장했던 로컬캐시를 다시 이용(검증헤더가 필요) -> Last-Modefied로 검증하고 HTTP BODY가 없음(304 Not-Modified)
    - 데이터 변경의 경우 : 200OK 새로 받아온다
      - 단점 : a->b->a 로 수정할경우 같지만 달라진다.
      
    - 서버에서 캐시 컨트롤을 하고싶을때 : ETag 이용
      - 캐시용 데이터에 고유 이름을 달아준다
      - 데이터가 변경되면 이 이름을 바꾸어 저장(Hash)
      - 캐시 제어 로직을 서버에서 완전히 관리 
  - 캐시 제어 헤더
    - Cache-control(캐시 지시어) : ex) max-age , no-cache , no-store
    - Pragma
    - Expire : 캐시 만료일을 정확하게 날짜로 지정 
  - 프록시 캐시
    - 원 서버로 데이터 요청하면 받는 시간이 느리니까 중간에 프록시 서버를 놓아서 캐시 받는 것

        
  - BODY
    - 본문을 통해 데이터 전달
    - 표현은 요청이나 응답에서 전달할 실제 데이터
    - 표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공




